<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XieHao&#39;s Blog</title>
  
  <subtitle>我当然是在扯淡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-10T02:21:44.889Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xie Hao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树的遍历总结</title>
    <link href="http://yoursite.com/2018/03/10/BinaryTree/"/>
    <id>http://yoursite.com/2018/03/10/BinaryTree/</id>
    <published>2018-03-10T02:13:34.000Z</published>
    <updated>2018-03-10T02:21:44.889Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的遍历主要有先序、中序、后序以及层序遍历四种。前三种遍历分别有递归和非递归两种方式，本文总结了这7种遍历的实现。</p><ul><li>先序遍历：根节点 -&gt; 左孩子 -&gt; 右孩子</li><li>中序遍历：左孩子 -&gt; 根节点 -&gt; 右孩子</li><li>后序遍历：左孩子 -&gt; 右孩子 -&gt; 根节点</li><li>层序遍历：从上往下逐层访问，每一层从左往右。</li></ul><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><blockquote><p>二叉树的先序、中序、后序的递归实现非常简单，大多数时候采用递归的方式。</p></blockquote><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先序遍历 递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</div><div class="line">    visit(root);</div><div class="line">    preOrder_1(root.left);</div><div class="line">    preOrder_1(root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中序遍历 递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</div><div class="line">        inOrder(root.left);</div><div class="line">        visit(root);</div><div class="line">        inOrder(root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//后序遍历 递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</div><div class="line">        postOrder(root.left);</div><div class="line">        postOrder(root.right);</div><div class="line">        visit(root);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><h3 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历的顺序是根节点 -&gt; 左孩子 -&gt; 右孩子，我们需要一个辅组栈来节点。对于一颗二叉树可以分为根节点、左孩子、右孩子三个部分，在左右孩子中可以继续分为根节点、左孩子、右孩子三个部分。对于这三个部分进行以下操作：</p><ol><li>访问当前节点（一开始为根节点），打印输出，并入栈。再看其左孩子是否为空。</li><li>若当前节点的左孩子不为空，则更新当前节点为其左孩子节点，回到1。</li><li>若当前节点的左孩子为空，弹出栈顶元素，更新当前节点为栈顶元素的右孩子，回到1。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先序遍历 非递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    BinaryTreeNode node = root;</div><div class="line">   Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack();</div><div class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span> || !stack.isEmpty())&#123;</div><div class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;<span class="comment">//一直到最左边节点</span></div><div class="line">        visit(node);</div><div class="line">            stack.push(node);</div><div class="line">            node = node.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!stack.isEmpty())&#123;</div><div class="line">        node = stack.pop();</div><div class="line">            node = node.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历与先序遍历的思路大致相同，按照以下步骤进行：</p><ol><li>将当前节点入栈，再看左孩子是否为空。</li><li>若当前节点的左孩子不为空，则更新当前节点为其左孩子节点，回到1。</li><li>若当前节点的左孩子为空，弹出栈顶元素，并且访问输出，更新当前节点为栈顶元素的右孩子，回到1。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中序遍历 非递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    BinaryTreeNode node = root;</div><div class="line">    Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack();</div><div class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span> || !stack.isEmpty())&#123;</div><div class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;<span class="comment">//一直到最左边节点</span></div><div class="line">            stack.push(node);</div><div class="line">            node = node.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!stack.isEmpty())&#123;</div><div class="line">            node = stack.pop();</div><div class="line">            visit(node);</div><div class="line">            node = node.right;</div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历的非递归实现稍微复杂了一点，由于后序的顺序是左孩子 -&gt; 右孩子 -&gt; 根节点，所以我们需要两次访问根节点：第一次访问根节点用来将其左右孩子入栈；第二次访问根节点输出节点信息。为了判别是第几次访问根节点，我们需要用一个指针来记录上一次访问的节点。如果上一次访问的是左右孩子则这一次将是第二次访问根节点，需要输出节点信息。操作步骤如下：</p><ol><li>根节点入栈。</li><li>cur指针指向栈顶元素。</li><li>若cur节点没有孩子节点或者孩子节点都已经被访问过了，则输出当前节点信息，出栈cur元素，用pre指针保存该元素。</li><li>若cur节点有孩子节点且没有访问过，则一次入栈右孩子、左孩子。回到2。</li><li>直到栈空。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//后序遍历 非递归</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder_2</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack();</div><div class="line">    BinaryTreeNode cur;         <span class="comment">//当前结点</span></div><div class="line">    BinaryTreeNode pre = <span class="keyword">null</span>;  <span class="comment">//前一次访问的结点</span></div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span>(!stack.empty()) &#123;</div><div class="line">        cur=stack.peek();</div><div class="line">        <span class="comment">//如果 当前节点没有孩子节点 || 孩子节点都已经被访问过了</span></div><div class="line">        <span class="keyword">if</span>((cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) ||</div><div class="line">           (pre != <span class="keyword">null</span> &amp;&amp; (pre == cur.left || pre == cur.right))) &#123;</div><div class="line">            visit(cur);</div><div class="line">            stack.pop();</div><div class="line">            pre = cur;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//先入栈右孩子再入栈左孩子，这样出栈的顺序才是先左后右</span></div><div class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</div><div class="line">                stack.push(cur.right);</div><div class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</div><div class="line">                stack.push(cur.left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>二叉树的层序遍历是从上到下，从左到右依次访问。采用队列实现，即从上到下、从左到右依次入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    Queue&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</div><div class="line">    queue.offer(root);</div><div class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">        BinaryTreeNode node = queue.poll();</div><div class="line">        visit(node);</div><div class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</div><div class="line">            queue.offer(node.left);</div><div class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</div><div class="line">            queue.offer(node.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉树的遍历主要有先序、中序、后序以及层序遍历四种。前三种遍历分别有递归和非递归两种方式，本文总结了这7种遍历的实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先序遍历：根节点 -&amp;gt; 左孩子 -&amp;gt; 右孩子&lt;/li&gt;
&lt;li&gt;中序遍历：左孩子 -&amp;gt; 根节点 -&amp;gt; 右
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>
