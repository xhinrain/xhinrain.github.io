<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树的遍历总结]]></title>
    <url>%2F2018%2F03%2F10%2FBinaryTree%2F</url>
    <content type="text"><![CDATA[二叉树的遍历主要有先序、中序、后序以及层序遍历四种。前三种遍历分别有递归和非递归两种方式，本文总结了这7种遍历的实现。 先序遍历：根节点 -&gt; 左孩子 -&gt; 右孩子 中序遍历：左孩子 -&gt; 根节点 -&gt; 右孩子 后序遍历：左孩子 -&gt; 右孩子 -&gt; 根节点 层序遍历：从上往下逐层访问，每一层从左往右。 递归实现 二叉树的先序、中序、后序的递归实现非常简单，大多数时候采用递归的方式。 先序遍历12345678//先序遍历 递归public static void preOrder(BinaryTreeNode root)&#123; if(root != null)&#123; visit(root); preOrder_1(root.left); preOrder_1(root.right); &#125;&#125; 中序遍历12345678//中序遍历 递归public static void inOrder(BinaryTreeNode root)&#123; if(root != null)&#123; inOrder(root.left); visit(root); inOrder(root.right); &#125;&#125; 后序遍历12345678//后序遍历 递归public static void postOrder(BinaryTreeNode root)&#123; if(root != null)&#123; postOrder(root.left); postOrder(root.right); visit(root); &#125;&#125; 非递归实现先序遍历先序遍历的顺序是根节点 -&gt; 左孩子 -&gt; 右孩子，我们需要一个辅组栈来节点。对于一颗二叉树可以分为根节点、左孩子、右孩子三个部分，在左右孩子中可以继续分为根节点、左孩子、右孩子三个部分。对于这三个部分进行以下操作： 访问当前节点（一开始为根节点），打印输出，并入栈。再看其左孩子是否为空。 若当前节点的左孩子不为空，则更新当前节点为其左孩子节点，回到1。 若当前节点的左孩子为空，弹出栈顶元素，更新当前节点为栈顶元素的右孩子，回到1。 123456789101112131415161718//先序遍历 非递归public static void preOrder(BinaryTreeNode root)&#123; if(root == null) return; BinaryTreeNode node = root; Stack&lt;BinaryTreeNode&gt; stack = new Stack(); while(node != null || !stack.isEmpty())&#123; while(node != null)&#123;//一直到最左边节点 visit(node); stack.push(node); node = node.left; &#125; if(!stack.isEmpty())&#123; node = stack.pop(); node = node.right; &#125; &#125;&#125; 中序遍历中序遍历与先序遍历的思路大致相同，按照以下步骤进行： 将当前节点入栈，再看左孩子是否为空。 若当前节点的左孩子不为空，则更新当前节点为其左孩子节点，回到1。 若当前节点的左孩子为空，弹出栈顶元素，并且访问输出，更新当前节点为栈顶元素的右孩子，回到1。 123456789101112131415161718//中序遍历 非递归public static void inOrder(BinaryTreeNode root)&#123; if(root == null) return; BinaryTreeNode node = root; Stack&lt;BinaryTreeNode&gt; stack = new Stack(); while(node != null || !stack.isEmpty())&#123; while(node != null)&#123;//一直到最左边节点 stack.push(node); node = node.left; &#125; if(!stack.isEmpty())&#123; node = stack.pop(); visit(node); node = node.right; &#125; &#125;&#125; 后序遍历后序遍历的非递归实现稍微复杂了一点，由于后序的顺序是左孩子 -&gt; 右孩子 -&gt; 根节点，所以我们需要两次访问根节点：第一次访问根节点用来将其左右孩子入栈；第二次访问根节点输出节点信息。为了判别是第几次访问根节点，我们需要用一个指针来记录上一次访问的节点。如果上一次访问的是左右孩子则这一次将是第二次访问根节点，需要输出节点信息。操作步骤如下： 根节点入栈。 cur指针指向栈顶元素。 若cur节点没有孩子节点或者孩子节点都已经被访问过了，则输出当前节点信息，出栈cur元素，用pre指针保存该元素。 若cur节点有孩子节点且没有访问过，则一次入栈右孩子、左孩子。回到2。 直到栈空。 1234567891011121314151617181920212223242526//后序遍历 非递归public static void postOrder_2(BinaryTreeNode root)&#123; if(root == null) return; Stack&lt;BinaryTreeNode&gt; stack = new Stack(); BinaryTreeNode cur; //当前结点 BinaryTreeNode pre = null; //前一次访问的结点 stack.push(root); while(!stack.empty()) &#123; cur=stack.peek(); //如果 当前节点没有孩子节点 || 孩子节点都已经被访问过了 if((cur.left == null &amp;&amp; cur.right == null) || (pre != null &amp;&amp; (pre == cur.left || pre == cur.right))) &#123; visit(cur); stack.pop(); pre = cur; &#125; else &#123; //先入栈右孩子再入栈左孩子，这样出栈的顺序才是先左后右 if(cur.right != null) stack.push(cur.right); if(cur.left != null) stack.push(cur.left); &#125; &#125;&#125; 层序遍历二叉树的层序遍历是从上到下，从左到右依次访问。采用队列实现，即从上到下、从左到右依次入队。 1234567891011121314public static void levelOrder(BinaryTreeNode root)&#123; if(root == null) return; Queue&lt;BinaryTreeNode&gt; queue = new LinkedList(); queue.offer(root); while(!queue.isEmpty())&#123; BinaryTreeNode node = queue.poll(); visit(node); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
</search>
